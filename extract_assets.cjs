const { Jimp } = require('jimp');
const fs = require('fs');
const path = require('path');

const CONFIG_PATH = 'src/config/fantasy-ui-atlas.json';
const OUT_DIR_BASE = 'src/assets/ui/fantasy';
const TYPES_OUT_PATH = 'src/types/fantasy-ui.generated.ts';

async function extract() {
    try {
        console.log('Loading atlas configuration...');
        const atlasConfig = JSON.parse(fs.readFileSync(CONFIG_PATH, 'utf8'));
        const sources = {};

        // 1. Load Sources
        for (const [key, relativePath] of Object.entries(atlasConfig.sources)) {
            const fullPath = path.resolve(process.cwd(), relativePath);
            console.log(`Loading source [${key}]: ${relativePath}`);
            if (fs.existsSync(fullPath)) {
                sources[key] = await Jimp.read(fullPath);
            } else {
                console.warn(`Warning: Source image not found at ${fullPath}`);
            }
        }

        const generatedTypes = {
            panels: [],
            containers: [],
            tabs: [],
            buttons: [] // Placeholder for future
        };

        const runtimeConfig = {
            panels: {},
            // Add other categories as needed for runtime config (like slice values)
        };

        // 2. Extract Assets
        const categories = ['panels', 'containers', 'tabs']; // Add 'buttons' when we have data

        for (const category of categories) {
            const items = atlasConfig[category];
            if (!items) continue;

            const outDir = path.join(OUT_DIR_BASE, category);
            if (!fs.existsSync(outDir)) {
                fs.mkdirSync(outDir, { recursive: true });
            }

            for (const [name, config] of Object.entries(items)) {
                console.log(`Processing [${category}] ${name}...`);
                const sourceImage = sources[config.source];

                if (sourceImage) {
                    const clone = sourceImage.clone();
                    clone.crop({ x: config.x, y: config.y, w: config.w, h: config.h });

                    const fileName = `${name}.png`;
                    const outPath = path.join(outDir, fileName);
                    await clone.write(outPath);
                    console.log(`  -> Saved to ${outPath}`);
                } else {
                    console.error(`  -> Failed: Source '${config.source}' not loaded.`);
                }

                // Collect for types
                generatedTypes[category].push(name);

                // Collect for runtime config if it has slice data
                if (config.slice) {
                    runtimeConfig.panels[name] = config.slice;
                }
            }
        }

        // 3. Generate TypeScript Definitions
        console.log('Generating TypeScript definitions...');
        const typeFileContent = `/**
 * This file is AUTO-GENERATED by extract_assets.cjs.
 * DO NOT EDIT MANUALLY.
 * Run 'npm run extract-assets' to regenerate.
 */

export type FantasyPanelVariant = ${generatedTypes.panels.map(t => `'${t}'`).join(' | ')};
export type FantasyContainerVariant = ${generatedTypes.containers.map(t => `'${t}'`).join(' | ')};
export type FantasyTabVariant = ${generatedTypes.tabs.map(t => `'${t}'`).join(' | ')};

export const FANTASY_UI_CONFIG = ${JSON.stringify(runtimeConfig, null, 4)} as const;
`;

        const typeDir = path.dirname(TYPES_OUT_PATH);
        if (!fs.existsSync(typeDir)) {
            fs.mkdirSync(typeDir, { recursive: true });
        }
        fs.writeFileSync(TYPES_OUT_PATH, typeFileContent);
        console.log(`Types generated at ${TYPES_OUT_PATH}`);

        console.log('Extraction complete.');

    } catch (err) {
        console.error('Extraction failed:', err);
        process.exit(1);
    }
}

extract();
